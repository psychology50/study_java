package assistLecture4;

//   연산자는 외워야 하긴 하지만 조건문과 같은 예제를 많이 풀어보시면 자연스레 따라 외워집니다.
// 보통 프로그래밍에선 암기를 미덕으로 여기지 않습니다. 물론 찾아보지 않고 머리에 다 들어가 있으면 엄~~~~~청 대단한 거긴 하지만
// 아무리 열심히 공부해서 머리속에 넣어 놓아도 꺼내서 쓰려는데 1분 정도 버퍼링이 걸린다면, 인터넷에서 빨리 검색해서 찾는 거랑 차이가 뭐냐? 라는 논리입니다.
//   따라서 암기 분야에서 당장 머리에 안 들어온다고 스트레스 받으실 필요가 없습니다. 조건문 예제 조금만 풀어도 그냥 외워지는 친구들입니다.

/*
	[1] 연산
	 	1. def. 데이터를 처리하여 결과를 산출하는 것.
	 	2. 용어
	 	   (1) 연산자   : 연산에 사용되는 표시나 기호 (+, -, ...)
	 	   (2) 피연산자 : 연산 대상이 되는 데이터 (변수)
	 	   (3) 연산식   : 연산자와 피연산자를 이용한 연산 과정
	 	3. 종류
	 	   (1) 산술 연산자
	 	   	   · 기능   : 사칙연산, 나머지 계산
	 	   	   · 연산자 : + , -, *, /, %
	 	   	   · 산출값 타입 : 숫자
	 	   (2) 부호 연산자
	 	       · 기능   : 음수 / 양수
	 	   	   · 연산자 : + , -
	 	   	   · 산출값 타입 : 숫자
	 	   (3) 문자열 연산자
	 	       · 기능   : 문자열 연결
	 	   	   · 연산자 : +
	 	   	   · 산출값 타입 : 문자열
	 	   (4) 대입 연산자
	 	       · 기능   : 우변의 값을 좌변의 변수에 대입
	 	   	   · 연산자 : =, +=, -=, *=, /=, %=, &=, ^=, |=, <<=, >>=, >>>=
	 	   	   · 산출값 타입 : 여러가지
	 	   (5) 증감 연산자
	 	       · 기능   : 1만큼 증가 / 감소
	 	   	   · 연산자 : ++ , --
	 	   	   · 산출값 타입 : 숫자
	 	   	     * 증감 연산자를 쓸 때 주의할 점, 변수의 앞에 붙느냐 뒤에 붙느냐에 따라 연산 순서가 조금 달라진다.
	 	   (6) 비교 연산자
	 	       · 기능   : 값을 비교
	 	   	   · 연산자 : == , !=, >, <, >=, <=, instanceof(객체타입확인)
	 	   	   · 산출값 타입 : boolean
	 	   (7) 논리 연산자
	 	       · 기능   : 논리를 따짐(설명하기가 애매하네요) NOT, AND, OR 연산
	 	   	   · 연산자 : !, &, |, &&, ||
	 	   	     * &와 && 차이 -> &는 무조건 양쪽의 조건을 검사하고, &&는 앞에서 false를 반환하면 뒤는 굳이 확인을 안 한다.
	 	   	   · 산출값 타입 : boolean
	 	   (8) 조건 연산자 (=삼항 연산자)
	 	       · 기능   : 조건식에 따라 A 또는 B 중 하나를 선택
	 	   	   · 연산자 : (조건식) ? A : B
	 	   	   · 산출값 타입 : 여러가지
	 	   (9) 비트 연산자
     		   · 기능   : 비트 NOT,AND,OR,XOT 연산
	 	   	   · 연산자 : ~, &, |, ^
	 	   	   · 산출값 타입 : 숫자, boolean
  		  (10) 쉬프트 연산자
     		   · 기능   : 비트를 좌측/우측으로 밀어서 이동
	 	   	   · 연산자 : << ,>> ,>>>
	 	   	   · 산출값 타입 : 숫자
 	 	4. 우선 순위 (블로그에 정리 되게 잘 되어 있길래 가져왔는데, 이거 참고하시면 될 것 같아요.)
 	 	   (1) 단항 > 이항 : -x + 6
 	 	   (2) 곱셈, 나눗셈 > 덧셈, 뺄셈 : x + 6 * y	 	   
 	 	   (3) 산술 > 비교 : x + 3 > y - 1	 	   
 	 	   (4) 비교 > 논리 : x > 5 && x < 10	   
 	 	   (5) 대입이 제일 마지막 : int ans = x + 6 / 2;
 	 	   (6) 괄호()로 묶으면 최우선 순위
 	 	   
  
 */

public class Practice_Operator {
	
	public static void main(String[] args) {
		
		// 연산자를 모두 설명 하기엔 다소 양이 많기 때문에 
		// 꼭 알아야 할 것들과 사용할 때 주의해야 할 것들 위주로 정리했습니다.
		
		
		// ========== 1. 부호 연산자 ========== //
		System.out.println("======= [1] 부호 연산자 =======\n");
		int x1 = 100;
		int result1 = +x1;  
		int result2 = -x1;
		System.out.println("result1 = " + result1);
		System.out.println("result2 = " + result2);
		
		short s1 = 100;
//		short result_err1 = -s1;  // err : 부호 연산자를 사용하면 int 타입으로 산출된다. (자동 형변환)
		int result3 = -s1;
		System.out.println("result3 = " + result3);
		
		
		// ========== 2. 증감 연산자 ========== //
		System.out.println("\n======= [2] 증감 연산자 =======\n");
		
		int x2 = 5;
		System.out.println("x2++ = " + x2++); // 5
		System.out.println("++x2 = " + ++x2); // 7
		System.out.println("x2++ = " + x2++); // 7
		System.out.println("x2 = " + x2); // 8
		
		// 증감 연산자가 변수의 앞에 오느냐 뒤에 오느냐에 따라 결과가 조금 다르게 출력될 수 있다.
		// 피연산자의 뒤에 오면 결과를 출력하고 1 증가시키지만, 앞에 오면 1 증가시키고 결과를 출력한다.
		
		
		// ========== 3. 논리 (부정) 연산자 ========== //
		System.out.println("\n======= [3] 논리 (부정) 연산자 =======\n");
		boolean logic = true;
		System.out.println("logic -> " + logic);
		
		System.out.println("!logic -> " + !logic);
		
		logic = !logic;
		logic = !logic; // 두 번 부정
		System.out.println("!(!logic) -> " + logic);
		
		
		// ========== 4. 산술 연산자 ========== //
		System.out.println("\n======= [4] 산술 연산자 =======\n");		
		
		// 사실 깊게 들어가볼까..하다가 형변환 관련된 내용이라 그냥 맛만 보겠습니다.. 기본적인 1+1 같은 연산은 하실 줄 아실테니 char타입 연산만 보여드리겠습니다.
		char c1 = 'A' + 1;	
		char c2 = 'A';
		
		System.out.println("c1 -> " + c1); // 'A'는 ASCII 코드 상 65의 번호를 가집니다. 그래서 1을 더하면 66인 'B'가 출력!
		System.out.println("c2 -> " + c2);
		
//		char c3_err = c2 + 1;  // err! --> c1은 되는데 c3는 안 된다. 이게 형변환 관련 문제라서 자세한 설명은 생략하겠습니다..ㅜ (양도 많고 설명 시간이 부족해요)
		
		// 중요한 건 연산을 할 때 최대한 서로 같은 타입으로 맞추는 것이 좋다.
		// 만약 불가피하게 자료형이 다른 값들을 더해야 할 때, 자료형의 바이트 크기를 고려해야 한다. (형 변환)
		
		
		// ========== 5. 비교 연산자 ========== //
		System.out.println("\n======= [5] 비교 연산자 =======\n");
		
		// 비교 연산자를 쓰는 방법은 아실겁니다. 그렇다면 이걸 언제 사용하느냐?
		// · String 타입 문자열은 대소 비교 연산자를 쓸 수 없습니다. (== , != 가능)
		// · 그렇다고 문자열 비교할 때 ==, !=를 쓰는 것도 아닙니다. 보통 equals() 메서드를 사용합니다.
		// · 비교 연산자는 boolean값을 산출합니다. 대체로 boolean값을 산출하는 연산자들은 제어문을 실행시킬 때 사용한다고 아시면 됩니다.
		int x3 = 0;
		while (x3 < 3) {
			System.out.println(x3 + "번 째 x3 = " + x3);
			x3++;
		}
		
		
		// ========== 6. 논리 연산자 ========== //
		System.out.println("\n======= [6] 논리 연산자 =======\n");
		
		/* · 논리 연산자의 피연산자는 boolean 타입만 사용 가능하다.
		   · 구분
			 - AND (논리곱)	: 둘 다 true여야 산출값 true	
		 	 - OR  (논리합) : 둘 중 하나만 true면 산출값 true
		 	 - XOR (배타적 논리합) : 서로 다르면 산출값 true
		 	 - NOT (논리부정) : 피연산자 논리값을 뒤집는다.
		*/
		
		int charCode = 'A'; // A는 아스키 코드 상 65의 번호를 가진다.
		if ((charCode >= 65) & (charCode <= 90)) {  // 65(=A) ~ 90(=Z)
			System.out.println("대문자입니다.");
		}
		if ((charCode >= 97) && (charCode <= 122)) {// 97(=a) ~ 122(=z)
			System.out.println("소문자입니다.");
		}
		if ((charCode >= 48) & (charCode <= 57)) {  // 48(=0) ~ 57(=9)  // char타입이라 숫자를 받아도 아스키 코드값으로 판단한다.
			System.out.println("0~9 숫자입니다.");
		}
		
		int value = 6;
		if ((value % 2 == 0) | (value % 3 == 0)) {
			System.out.println("2 또는 3의 배수이다.");
		}
		if ((value % 2 == 0) || (value % 3 == 0)) {
			System.out.println("2 또는 3의 배수이다.");
		}
		
		// Q. &와 && , |와 ||의 차이는 뭔가요?
		// A. 사실 몰라도 전혀 상관 없습니다. '&'는 두 조건을 모두 확인하는 것이고, 
		//    '&&'는 앞에만 확인해보고 조건에 안 맞으면 뒤는 확인해볼 필요 없으니 그냥 건너 뛰겠다는 겁니다.
		//    아주 근소한 차이의 연산 속도 차이가 있을 수는 있습니다.
		
		
		// ========== 7. 대입 연산자 ========== //
		System.out.println("\n======= [7] 대입 연산자 =======\n");
		
		// 처음에 많이들 헷갈려 하시지만 이해하면 엄청 간단합니다.
		// 변수 = 변수 '연산자' 피연산자  ex) a = a + 2			(단순 대입)
		// 변수 '연산자'= '피연산자'      ex) a += 2			(복합 대입)
		// 이 차이밖에 없습니다. 잘 쓰면 가독성이 올라가기도 하고, for문 증감문을 수정할 때 써야해서 알아두어야 합니다.
		int x4 = 1;
		x4 *= 5;
		System.out.println("x4 = " + x4);
		
		
		// ========== 8. 삼항 연산자 ========== //
		System.out.println("\n======= [8] 삼항 연산자 =======\n");		
		 
		int x5;
		int a = 5, b = 6;
		
		// if문
		if (a>b) {
			x5 = 50;
		}
		else {
			x5 = 40;
		}
		System.out.println(x5);
		
		// 삼항 연산자
		int x6 = (a>b) ? 50 : 40;
		
		// 문제는 삼항 연산자를 쓴다고 연산 속도가 빨라지는 것도 아니고, 가독성이 엄청 높아지는 것도 아닙니다.
		// 어떻게 보면 전체적인 코드는 줄어들 수 있어도, 가독성은 더 떨어질 수도 있기 때문에 잘 안 쓰입니다. 그냥 개념만 익혀두시면 됩니다.
		
		
		
		
	}

}
